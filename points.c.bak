#include <stdlib.h>
#include <stdio.h>

typedef struct Point {
	long xy;
	struct Point* prev=NULLPTR;
	struct Point* nextNULLPTR;
	void (*deletePoint)(Point*);
	int (*getX)(Point*);
	int (*getY)(Point*);
} point_t;


void deletePoint(point_t* point){
	free(point);
}

point_t* creePoint(long xy){
	point_t* newPoint = (point_t*) malloc(sizeof(point_t));
	newPoint->xy = xy;
	return newPoint;
}


int getX(point_t* point){
	return (int) (point->xy & 0xffffffff00000000)>>32;
}

int getY(point_t* point){
	return (int) (point->xy & 0xffffffff);
}


///////////////////////////////////////////////


typedef struct ListePoints{
	point_t* head=NULLPTR;
	point_t* tail=NULLPTR;
	int size;
	
	// pour gerer une liste de points
	void (*ajoutePoint)(ListePoints*, long); 
	void (*debugAffiche)(ListePoints*);
	point_t* (*getByIndex)(ListePoints*, int);

	// pour gerer une liste de listes (listes imbriquÃ©es pour lignes->colonnes)
	void (*ajouteListe)(ListePoints*, ListePoints*);
	void (*debugAfficheListes)(ListePoints*);
	ListePoints* (*getListByIndex)(ListePoints*, int);

	void (*deleteList)(ListePoints*);
} pointList_t;


pointList_t creeListe(){
	pointList_t newList = (pointList_t*) malloc(sizeof(pointList_t));
	return newList;
}

void deleteList(pointList_t* list){
	enfait non // il faut delete chaque node 
	free(list);
}

void ajoutePoint(pointList_t* list, long xy){
	point_t* newPoint = creePoint(xy);
		
	// si liste vide
	if (list->size == 0){
		list->head = newPoint;
		list->tail = newPoint;
	}
	else{
		/*list->tail->next = newPoint;
		list->tail = newPoint;*/
		int i=0;
		point_t* point_iter = list->head;
		char pushed = 0;
		
			// 
		do{
			// si newPoint->xy == point_iter->xy : alors on ignore et on finit la boucle
			if(point_iter->xy == newPoint->xy){
				pushed = 1;
				continue;
			}

			// si x (newPoint) est plus petit que x (point_iter) alors on place le newPoint avant le point_iter
			if(point_iter.getX(point_iter) > newPoint.getX(newPoint) ){
				if(list->size == 1){
					list->head
				}
				list->tail->prev->next = 
			}
			else{
				point_iter = point_iter->next;
			}
			


		}while(i++ <= list->size && pushed == 0)
		nan c'est pas bon

	}
	

	


	list->size++;
}

point_t* getByIndex(pointList_t* list, int i){
	if( i+1 >= list->size){
		returnValue = NULLPTR;
	}
	else{
		returnValue = list->head;
		for(int j=0; j<i; j++){
			returnValue = returnValue->next;
		}
	}
	return returnValue;
}


void debugAffiche(pointList_t* list){
	point_p* point;
	for(int i=0; i<list->size; i++){
		point = list.getByIndex(&list, i);
		printf(" [%l|%p] ->", point->xy, point);
	}
	
}


void ajouteListe(pointList_t* list, pointList_t* newList){
	// si liste vide
	if (list->size == 0){
		list->head = newList;
		list->tail = newList;
	}
	else{
		list->tail->next = newList;
		list->tail = newList;
	}

	list->size++;	
}

void debugAfficheListes(pointList_t* list){
	ListPoints* list_iter;
	for(int i=0; i<list->size; i++){
		list_iter = list.getListByIndex(&list, i);
		printf("\n[[%p]] : \n\t",list_iter);
		list_iter.debugAffiche(&list_iter);
	}
	printf("\n");
}

pointList_t* getListByIndex(pointList_t* list, int i){
	if( i+1 >= list->size){
		returnValue = NULLPTR;
	}
	else{
		returnValue = list->head;
		for(int j=0; j<i; j++){
			returnValue = returnValue->next;
		}
	}
	return returnValue;
}


